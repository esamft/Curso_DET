-- =====================================================
-- DET Flow - Initial Database Schema for Supabase
-- =====================================================
-- Version: 1.0.0
-- Date: 2025-02-07
-- Description: Creates tables for users, submissions, sessions, and study plans
-- =====================================================

-- Enable UUID extension if not already enabled
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- =====================================================
-- Table: users
-- Stores student information and profile data
-- =====================================================
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    phone_number VARCHAR(20) UNIQUE NOT NULL,
    name VARCHAR(255),
    email VARCHAR(255) UNIQUE,

    -- Profile information
    target_score INTEGER CHECK (target_score >= 10 AND target_score <= 160),
    current_level VARCHAR(10) CHECK (current_level IN ('A1', 'A2', 'B1', 'B2', 'C1', 'C2')),

    -- Tracking
    total_submissions INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ,
    last_active TIMESTAMPTZ,

    -- Status
    is_active BOOLEAN DEFAULT TRUE,
    subscription_tier VARCHAR(50) DEFAULT 'free' CHECK (subscription_tier IN ('free', 'premium', 'pro'))
);

-- Create indexes for users table
CREATE INDEX idx_users_phone ON users(phone_number);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_active ON users(is_active);

-- =====================================================
-- Table: submissions
-- Stores student responses and evaluation results
-- =====================================================
CREATE TABLE IF NOT EXISTS submissions (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Task information
    task_type VARCHAR(50) NOT NULL,
    task_prompt TEXT,

    -- Student response
    response_text TEXT,
    response_audio_url VARCHAR(512),
    response_image_url VARCHAR(512),

    -- Evaluation results (DET 10-160 scale)
    overall_score INTEGER CHECK (overall_score >= 10 AND overall_score <= 160),

    -- Subscores (each 10-160)
    literacy_score INTEGER CHECK (literacy_score >= 10 AND literacy_score <= 160),
    comprehension_score INTEGER CHECK (comprehension_score >= 10 AND comprehension_score <= 160),
    conversation_score INTEGER CHECK (conversation_score >= 10 AND conversation_score <= 160),
    production_score INTEGER CHECK (production_score >= 10 AND production_score <= 160),

    -- Detailed feedback (stored as JSONB for flexible querying)
    feedback JSONB,
    evaluator_comments TEXT,

    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    evaluated_at TIMESTAMPTZ,
    evaluation_duration_ms INTEGER,

    -- Status
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'evaluating', 'completed', 'failed'))
);

-- Create indexes for submissions table
CREATE INDEX idx_submissions_user_id ON submissions(user_id);
CREATE INDEX idx_submissions_status ON submissions(status);
CREATE INDEX idx_submissions_created_at ON submissions(created_at DESC);
CREATE INDEX idx_submissions_task_type ON submissions(task_type);
CREATE INDEX idx_submissions_overall_score ON submissions(overall_score);

-- Create index on JSONB feedback column for faster queries
CREATE INDEX idx_submissions_feedback ON submissions USING GIN (feedback);

-- =====================================================
-- Table: user_sessions
-- Tracks conversation sessions for continuity
-- =====================================================
CREATE TABLE IF NOT EXISTS user_sessions (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Session data
    session_id VARCHAR(255) UNIQUE NOT NULL,
    context JSONB,

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    last_interaction TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ,

    -- Status
    is_active BOOLEAN DEFAULT TRUE
);

-- Create indexes for user_sessions table
CREATE INDEX idx_user_sessions_user_id ON user_sessions(user_id);
CREATE INDEX idx_user_sessions_session_id ON user_sessions(session_id);
CREATE INDEX idx_user_sessions_is_active ON user_sessions(is_active);

-- =====================================================
-- Table: study_plans
-- Stores personalized study plans generated by Pedagogue Agent
-- =====================================================
CREATE TABLE IF NOT EXISTS study_plans (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Plan details
    title VARCHAR(255) NOT NULL,
    description TEXT,
    plan_data JSONB NOT NULL,

    -- Duration
    start_date TIMESTAMPTZ,
    end_date TIMESTAMPTZ,
    duration_weeks INTEGER,

    -- Progress tracking
    completion_percentage NUMERIC(5,2) DEFAULT 0.0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ,

    -- Status
    is_active BOOLEAN DEFAULT TRUE
);

-- Create indexes for study_plans table
CREATE INDEX idx_study_plans_user_id ON study_plans(user_id);
CREATE INDEX idx_study_plans_is_active ON study_plans(is_active);
CREATE INDEX idx_study_plans_created_at ON study_plans(created_at DESC);

-- Create index on JSONB plan_data column
CREATE INDEX idx_study_plans_plan_data ON study_plans USING GIN (plan_data);

-- =====================================================
-- Triggers for updated_at timestamps
-- =====================================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply trigger to users table
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Apply trigger to study_plans table
CREATE TRIGGER update_study_plans_updated_at
    BEFORE UPDATE ON study_plans
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- Views for Analytics and Reporting
-- =====================================================

-- View: User Progress Summary
CREATE OR REPLACE VIEW user_progress_summary AS
SELECT
    u.id AS user_id,
    u.phone_number,
    u.name,
    u.current_level,
    u.target_score,
    u.total_submissions,
    COUNT(s.id) AS evaluated_submissions,
    ROUND(AVG(s.overall_score), 2) AS avg_score,
    MAX(s.overall_score) AS best_score,
    MIN(s.overall_score) AS lowest_score,
    ROUND(AVG(s.literacy_score), 2) AS avg_literacy,
    ROUND(AVG(s.comprehension_score), 2) AS avg_comprehension,
    ROUND(AVG(s.conversation_score), 2) AS avg_conversation,
    ROUND(AVG(s.production_score), 2) AS avg_production,
    MAX(s.created_at) AS last_submission_date
FROM
    users u
    LEFT JOIN submissions s ON u.id = s.user_id AND s.status = 'completed'
GROUP BY
    u.id, u.phone_number, u.name, u.current_level, u.target_score, u.total_submissions;

-- View: Recent Activity
CREATE OR REPLACE VIEW recent_activity AS
SELECT
    s.id,
    s.user_id,
    u.phone_number,
    u.name,
    s.task_type,
    s.overall_score,
    s.created_at,
    s.status
FROM
    submissions s
    JOIN users u ON s.user_id = u.id
ORDER BY
    s.created_at DESC
LIMIT 100;

-- =====================================================
-- Row Level Security (RLS) Policies for Supabase
-- =====================================================

-- Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE submissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE study_plans ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only read their own data
CREATE POLICY users_select_own ON users
    FOR SELECT
    USING (auth.uid()::text = id::text);

-- Policy: Submissions - users can read their own submissions
CREATE POLICY submissions_select_own ON submissions
    FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth.uid()::text = id::text));

-- Policy: User sessions - users can read their own sessions
CREATE POLICY user_sessions_select_own ON user_sessions
    FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth.uid()::text = id::text));

-- Policy: Study plans - users can read their own plans
CREATE POLICY study_plans_select_own ON study_plans
    FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth.uid()::text = id::text));

-- =====================================================
-- Sample Data (Optional - for testing)
-- =====================================================

-- Uncomment to insert sample data for testing

-- INSERT INTO users (phone_number, name, email, target_score, current_level)
-- VALUES
--     ('+5511999999999', 'JoÃ£o Silva', 'joao@example.com', 120, 'B1'),
--     ('+5511888888888', 'Maria Santos', 'maria@example.com', 140, 'B2');

-- =====================================================
-- Functions for Common Queries
-- =====================================================

-- Function: Get user statistics
CREATE OR REPLACE FUNCTION get_user_stats(user_id_param INTEGER)
RETURNS TABLE (
    total_submissions BIGINT,
    avg_score NUMERIC,
    best_score INTEGER,
    improvement_trend NUMERIC,
    weak_areas TEXT[]
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        COUNT(s.id) AS total_submissions,
        ROUND(AVG(s.overall_score), 2) AS avg_score,
        MAX(s.overall_score) AS best_score,
        -- Calculate improvement trend (difference between recent 5 and previous 5)
        (
            SELECT ROUND(AVG(overall_score), 2)
            FROM (SELECT overall_score FROM submissions WHERE user_id = user_id_param ORDER BY created_at DESC LIMIT 5) recent
        ) - (
            SELECT ROUND(AVG(overall_score), 2)
            FROM (SELECT overall_score FROM submissions WHERE user_id = user_id_param ORDER BY created_at DESC LIMIT 10 OFFSET 5) previous
        ) AS improvement_trend,
        -- Identify weak areas (subscores below 100)
        ARRAY_AGG(DISTINCT weak_area) FILTER (WHERE weak_area IS NOT NULL) AS weak_areas
    FROM
        submissions s,
        LATERAL (
            SELECT
                CASE
                    WHEN s.literacy_score < 100 THEN 'Literacy'
                    WHEN s.comprehension_score < 100 THEN 'Comprehension'
                    WHEN s.conversation_score < 100 THEN 'Conversation'
                    WHEN s.production_score < 100 THEN 'Production'
                END AS weak_area
        ) areas
    WHERE
        s.user_id = user_id_param
        AND s.status = 'completed';
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- Completion Message
-- =====================================================

-- Add a comment to track migration version
COMMENT ON SCHEMA public IS 'DET Flow Schema Version 1.0.0';

SELECT 'DET Flow database schema created successfully!' AS message;
